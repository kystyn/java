# Лабы по джаве (DEPRECATED)


Ведется [работа](https://github.com/winter-yuki/spbstu-amd-java) над лабораторными для следующих поколений приматов. Там же актуальная версия [шпоровых колоний](https://github.com/winter-yuki/spbstu-amd-java/blob/master/TRICKY.md). Люди уже активно сдают лабу по новой версии. Интерфейс сильно проще этого за счет более грамотного выделения сущностей, соответствует всему набору требований, которым текущий интерфейс пытался удовлетворить по ходу дела. Если уже написана вторая лаба, переходить на новую версию, наверное, смысла нет.

В курсе 4 лабораторные работы. Они вместе складываются в один проект - многопоточный архиватор.

[jar для второй](https://drive.google.com/open?id=1V1403Yh38zu5KnZhIjAyO3Tafi8ATXpO). 
Код второй в ветке [lab2](https://github.com/kystyn/java/tree/lab2/pipeline).

[jar для третьей](https://drive.google.com/open?id=1sYT5ZSvtTemLk1aUKl89PxvsbyJ8ovta)


## Разное

Вопросы и пожелания, пожалуйста, пишите в [issues](https://github.com/kystyn/java/issues).

По интерфейсам см также комментарии в исходниках.


## Шпоровые колонии

#### Поля и переменные

- field: static final
    - не инит по умолчанию
    - инит через = или в статик конструкторе
- field: static
    - инит по умолчанию
    - инит где угодно + статик конструктор
- field: final
    - не инит по умолчанию
    - инит через = или в конструкторе
- field:
    - инит по умолчанию
    - инит где угодно
- local: final
    - не инит по умолчанию
    - инит только один раз перед использованием
- local:
    - не инит по умолчанию
    - инит перед использованием
    
#### Касты

- Касты чисел
    - Целые в целые которые больше
    - Дробные так же
    - 
      ```
      final int i = -128;
      byte b = i;
      ```
      (без final не сработает, если число в меньший тип не поместится, то тоже не сработает) 
      (с дробными не сработает)
    - остальное - CE
- Автоматический boxing/unboxing
    ```
    double d = new Double(5);
    Integer i = 5;
    ```
- Касты ссылочных
    - Upcast:
        ```
        class A {}
        class B extends A {}
        A a = new B();
        ```
    - Ковариантность/контравариантность
        типа так
        ```
        Set<? extends Number> ss = new HashSet<Integer>();
        ```
        + штуки с <? super T>
    - Остальное - CE
- Касты массивов
    - В надтип ссылочного типа
        ```
        Object[][] os = new Integer[0][0];
        ```
        (массив нулевой длины, кстати, сделать можно, а -1й - RE)
    - Массивы примитивных типов никуда не кастятся
    - ```Object o = new int[0][0];``` Массивы - тоже почти честные объекты!

    
#### Статическое и не очень

- Статики - атрибуты типов, если знаем тип, то можем достать нужный статик (если модификаторы доступа позволят)
- Не статики - атрибуты объектов типов. Их можно получить только через экземпляр.

    
#### Файлы, пакеты и все-все-все!

- В файле с именем `AAA` может быть не более одного публичного класса, и если он есть, он должен называться `AAA`
- Пакеты `ru.penguin.cooking` и `ru.penguin` никак не связаны иерархически. Штуки, видные в пределах пакета
не видны в "подпакетах", ибо таковых не бывает.

#### Модификаторы доступа
- class, который в файле с отступом 0 слева.
    - без модификатора (package private) - виден только в этом же пакете. (В подпакетах не виден, т.к. их не бывает)
    - public - виден всем (помним про имя этого файла тогда)
    - private - не бывает, уходим в котлин.
- class, вложенный в другой
    - public - виден всем
    - private - виден внутри объемлющего класса
    - protected - виден наследникам
- методы - все как и ожидается
- в отличие от плюсов
    ```
    class A{
        protected void foo() {...}
    }
    class B extends A {
        void bar() {
            C = new C();
            c.foo(); // Нельзя дергать протектед штуки из другой иерархии!!!
        }
    class C extends A {}
    ```
- final у класса - от него нельзя наследоваться
- final у метода - его нельзя переопределить в наследнике
- final у static метода - ... это как?

#### Вложенные static и не очень классы
- static - обычные классы, ничего не знают про внешний класс, его имя - просто пространство имен
   ```
    class A { static class AA {} }
    A.AA aa = new A.AA();
    ```
- не static - держат ссылку на внешний класс, имеет доступ ко всем, даже приватным членам внещнего класса
    ```
    class A{
        class AA {
            public getI() { return i; }
        }
        private int i = 64;
    }
    A.AA aa = new A().new AA();
    int outerI = aa.getI();
    ```

#### Ф-ции с переменным числом аргументов
    TODO
    
#### Дженерики

- дружат с массивами как кошка с собакой. Единственный вариант использования вместе (`?`  - wildcard!):
  ```
  List<?> xs = ...;
  ```
TODO


## Общие требования

- SDK 1.8 (Java8 и меньше, соответственно)
- Максимально избегайте хардкода, разделяйте код и данные. 
Например, информация о формате конфигурационного файла должна хваниться в статических полях класса-парсера
(какие символы-разделители используется и т.п.).
- Функция, которую задает алгоритм, должна быть биективной 
(т.е. последовательно применения архиватора и деархиватора должно давать исходный файл).
- Алгоритм должен быть 
[поточным](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC),
т.е. при любом объеме входных данных использовать константное количество оперативной памяти.
(иначе как кино в 40 гигов архивировать).
Таким образом, приложение в цикле должно читать блоки фиксированного размера из файла и 
их последовательно обрабатывать (и сразу записывать в выходной файл), 
пока входной файл не кончится.


## Lab 1

1. Реализовать алгоритм кодирования по вариантам.
2. Реализовать простейшее приложение-архиватор.

#### Пользовательский интерфейс приложения

- Приложение принимает один аргумент командной строки - путь к конфигурационному файлу.
- В конфиге содержится вся информация для работы приложения. Грамматика конфига произвольная.
    - Мод работы (архивировать/деархивировать).
    - Размер буфера.
    - Входной и выходной файлы.
    - мб еще что-нибудь...
- Пользователю в `stdout` должны выводиться осмысленные ошибки, 
не надо пугать пользователя! (т.е. не падать просто на исключениях)
- Подробные данные об ошибках писать в лог. Можно использовать `java.util.logging.Logger'.


## Lab 2

- см Lab3
- отличия от третьей
    - При знакомстве сохраняют ссылки друг на друга, не более.
    - С забирает данные не через какой-то ```DataAccessor```, а напрямую через ```get()``` (с.м. [исходники](https://github.com/kystyn/java/tree/lab2/pipeline) интерфейса второй лабы).


## Lab 3

### UPD

- Ниже описывается контракт для интерфейса `Executor`. 
Гарантируется что при дословном его соблюдении любые две реализации смогут ужиться и работать вместе.
- Никто не запрещает выполнять его лишь частично (например, забить на кодировки).
Но тогда нет гарантии абсолютной совместимости.
- Постулируется лишь интерфейс `Executor`, все остальное можно менять как угодно.
Например, сделать ```interface MyReader extends Reader, Fallible {}```. 


### Знакомство

Manager читает конфиг и выстраивает экзекуторов на конвейер. 
Делает он это в порядке, описанном в конфиге. 
Конвейер получается знакомством соседних экзекуторов.

Считаем что у нас на руках два экзекутора, P и С со статусами OK. Будем их знакомить.

1. ```P.addConsumer(C);```
    - тут P просто сохраняет ссылку на C.
2. ```C.addProducer(P);```
    1. C вызывает ```P.outputDataTypes()```
    2. ```P.outputDataTypes()``` возвращает множество строк - имена типов, 
    в виде которых P может отдавать данные.
    3. С из множества имен типов выбирает один - тот, 
    в каком C хочет получать данные (напр, ```byte[]```).
        - Если же желаемого типа не оказалось, C ставит
        ```status = Status.EXECUTOR_ERROR``` и прекращает общение.
    4. С вызывает ```P.getAccessor(byte[].class.getCanonicalName)``` 
    (подставляем имя того типа, который выбрали).
    5. ```P.getAccessor``` возвращает экземпляр класса, 
    который у продьюсера вложенный и унаследован от ```Producer.DataAccessor```.
    C сохраняет у себя этот экземпляр.
    
На этом знакомство закончилось!

##### DataAccessor

Посмотрим что это такое. Вот пример куска кода продьюсера:
```

private Object output;

private final class DataAccessor implements Producer.DataAccessor {

    @NotNull
    @Override
    public Object get() {
        return output;  // некоторое поле в P
    }

    @Override
    public long size() {
        Objects.requireNonNull(output);
        
        // тут мы знаем, что output это массив, 
        // если строка, вернули бы ((String) output).length()
        return ((byte[]) output).length;  
    }
}

@NotNull
@Override
public Producer.DataAccessor getAccessor(@NotNull final String typeName) {
    // сохраняем себе имя типа, в который будем конвертировать перед отдачей.
    this.outputTypeName = typeName; 
    return new DataAccessor();
}
```

Таким образом, ```DataAccessor``` позволяет C ходить в P и забирать данные.

Также, ```DataAccessor``` может в ```get()``` содержать логику конвертации в выбранный С тип данных,
зависит от реализации.


### Рабочий процесс конвейера

Итак, мы познакомили всех экзекуторов, тем самым сделали конвейер.

##### Запуск!

1. Manager (M) вызывает у первого на конвейере, ридера (R), метод ```R.run()```.
2. В ```run()``` ридер в цикле читает файл по блокам и отправляет на конвейер, работает как продьюсер.

##### Взаимодействие P и C

Допустим, продьюсер обработал данные 
(если продьюсер здесь это ридер, то просто прочитал данные из файла),
сконвертировал в нужный C тип и сложил в переменную output. 
(если произошла ошибка в конвертации или обработке, ставим ```status = Status.EXECUTOR_ERROR``` и делаем ```return```,
не трогая C).

Т.е. мы находимся в методе ```run()``` у P.

Дальше:
1. P вызывает у C ```C.loadDataFrom(this);```
    1. Там С забирает ссылку на данные у продьюсера через сохраненный аксессор:
    ```input = dataAccessor.get()```
    2. Если размер у данных (```dataAccessor.size()```) не равен ожидаемому, ```return 0```
    3. Иначе ```return dataAccessor.size();```
2. P смотрит что вернул ```C.loadDataFrom(this);```
    1. Если вернулся ноль, ставим ```status = Status.EXECUTOR_ERROR;``` и делаем ```return```
    2. Если не ноль, вызываем ```C.run()```
3. После того как ```C.run()``` отработал, ставим ```this.status = C.status()```
    - таким образом статус ошибки, если появится, дойдет до R и тот завершит цикл.
    

### Типы
- поддерживаем
    - byte[]
    - char[]
    - String
- Входной файл должен быть в кодировке UTF-16BE
(можно в idea выбрать справа снизу и переконвертировать)
- Тогда конвертация в коде ваглядит так:
    - ```new String(chars).getBytes("UTF-16BE")``` (char\[\] -> byte\[\])c
    - ```new String(bytes, "UTF-16BE").toCharArray()``` (byte\[\] -> char\[\])
    - к тому же можно полагаться что размер ```byte[]``` в этой кодировке
    будет вдвое длиннее соттветствующего ```char[]```



## Lab 4 

Теперь сделаем архиватор многопоточным. 

Достаточно чтобы работала такая схема:

![scheme](https://i.postimg.cc/jSdh4GXG/java-old-lab4.png)

#### Работа с потоками

Порождение потока - не дешевая операция (но и не слишком дорогая, но все равно...), 
поэтому не будем создавать по 
потоку на каждую порцию данных.

- `Manager` получает данные о количестве потоков из своего конфига, 
знакомит работников с `R` и `W`, выставляя их на конвейер. 
Затем создает для каждого по потоку и запускает их:
    ```
    ...
    for (Executor e : executors) {
        Thread thread = new Thread(e);
        thread.start(); 
    }
    ...
    ```
    [Ничего страшного](https://stackoverflow.com/questions/9651842/will-main-thread-exit-before-child-threads-complete-execution), что главный поток живет меньше дочерних.
- В `run()` каждого `E` находится цикл, в котором он запрашивает данные у `R`,
обрабатывает и отдает в `W`.
- Цикл работает, пока `R` не сообщит, что данных больше не будет.
- Выходной файл должен собраться правильно, поэтому нужно, 
чтобы `R` внимательно раздавал данные 
(а для этого ему нужно знать, какой именно `E` к нему сейчас обращается),
и чтобы `W` собирал данные в правильном порядке.
- Код `R` и `W` используется из многих потоков, поэтому целесообразно пометить их методы как `synchronized`.

Обратная совместимость с предыдущими лабораторными не требуется, но...

#### Lab 3 -> Lab 4

Несложно удовлетворить требованиям выше на интерфейсе для третьей лабы.
(Но в принципе можно воротить что-то принципиально новое).

- В общении `R` и `E` инициатором является `E`, поэтому логика `R` отрабатывает в `DataAccessor.get()`, и, конечно, `R` никакой `loadDataFrom` не дергает. Вниз по течению конвейера все по-старому.
- `R` может узнавать, какой `E` к нему обращается по `DataAccessor`, который ему был выдан.
- Для каждого `E` можно выделить в `R` по ячейке памяти, к которой у него будет доступ через `DataAccessor`.
В этих ячейках хранятся ссылки на данные, поэтому операции с ними атомарны (синхронизация потоков на них не нужна).
- Есть несколько вариантов, как `R` отдавать данные экзекуторам в нужном порядке, 
вне зависимости от того, в каком экзекуторы их запрашивают:
    1. В ячейке держать `null`, пока данных нет, не `null` - иначе.
     (И занулять после удачной попытки `E` обратиться к этой ячейке).
     Но не забываем, что нам нужно уметь через `DataAccessor` уметь сообщать о конце данных,
     для этого нужно будет придумать отдельную штуку.
     `E` когда видит ноль на итерации своего цикла, переходит просто на следующую 
     (можно его тред в сон отправить на долю секунды (`Thread.sleep(2000);`), 
     или что лучше - воспользоваться `wait()` + `notifyAll()`).
    2. Красивый, но существенно более сложный вариант. 
    `R` держит mutex на каждую ячейку (либо через `ожидание условия` (`volatile` флажок, `wait()`...)).
    Когда он из конкретной ячейки готов отдать данные, он отпускает ee блок, 
    а потом в `DataAccessor.get()` сразу берет его опять.
    Тогда можно о конце данных оповещать, отдавая `null` из ячейки.
    
    
#### Thread vs exception!

1. Из `run()`, который запустил `thread.start()` не должно вылетать исключений...
2. Если все-таки планируется что они будут вылетать, можно повесить 
[exception handler](https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html),
и в нем обрабатывать на границе потока. Это сделать обязательно, так как дефолтное поведение - убийство процесса.


