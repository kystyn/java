В курсе 4 лабораторные работы. Они вместе складываются в один проект - многопоточный архиватор.

[jar для второй](https://drive.google.com/open?id=1V1403Yh38zu5KnZhIjAyO3Tafi8ATXpO). 
Код второй в ветке [lab2](https://github.com/kystyn/java/tree/lab2/pipeline).

[jar для третьей](https://drive.google.com/open?id=1sYT5ZSvtTemLk1aUKl89PxvsbyJ8ovta)


## Разное

Ведется [работа](https://github.com/winter-yuki/spbstu-amd-java) над лабораторными для следующих поколений приматов. Там же актуальная версия [шпоровых колоний](https://github.com/winter-yuki/spbstu-amd-java/blob/master/TRICKY.md). Можно вносить свой вклад. Также можно тестить интерфейс, он сильно проще этого за счет более грамотного выделения сущностей, но преподаватель его еще пока не видел и не благословил, хотя он соответствует всему набору требований, которым текущий интерфейс пытался удовлетворить по ходу дела.

Вопросы и пожелания, пожалуйста, пишите в [issues](https://github.com/kystyn/java/issues).

По интерфейсам см также комментарии в исходниках.


## Шпоровые колонии

#### Поля и переменные

- field: static final
    - не инит по умолчанию
    - инит через = или в статик конструкторе
- field: static
    - инит по умолчанию
    - инит где угодно + статик конструктор
- field: final
    - не инит по умолчанию
    - инит через = или в конструкторе
- field:
    - инит по умолчанию
    - инит где угодно
- local: final
    - не инит по умолчанию
    - инит только один раз перед использованием
- local:
    - не инит по умолчанию
    - инит перед использованием
    
#### Касты

- Касты чисел
    - Целые в целые которые больше
    - Дробные так же
    - 
      ```
      final int i = -128;
      byte b = i;
      ```
      (без final не сработает, если число в меньший тип не поместится, то тоже не сработает) 
      (с дробными не сработает)
    - остальное - CE
- Автоматический boxing/unboxing
    ```
    double d = new Double(5);
    Integer i = 5;
    ```
- Касты ссылочных
    - Upcast:
        ```
        class A {}
        class B extends A {}
        A a = new B();
        ```
    - Ковариантность/контравариантность
        типа так
        ```
        Set<? extends Number> ss = new HashSet<Integer>();
        ```
        + штуки с <? super T>
    - Остальное - CE
- Касты массивов
    - В надтип ссылочного типа
        ```
        Object[][] os = new Integer[0][0];
        ```
        (массив нулевой длины, кстати, сделать можно, а -1й - RE)
    - Массивы примитивных типов никуда не кастятся
    - ```Object o = new int[0][0];``` Массивы - тоже почти честные объекты!

    
#### Статическое и не очень

- Статики - атрибуты типов, если знаем тип, то можем достать нужный статик (если модификаторы доступа позволят)
- Не статики - атрибуты объектов типов. Их можно получить только через экземпляр.

    
#### Файлы, пакеты и все-все-все!

- В файле с именем `AAA` может быть не более одного публичного класса, и если он есть, он должен называться `AAA`
- Пакеты `ru.penguin.cooking` и `ru.penguin` никак не связаны иерархически. Штуки, видные в пределах пакета
не видны в "подпакетах", ибо таковых не бывает.

#### Модификаторы доступа
- class, который в файле с отступом 0 слева.
    - без модификатора (package private) - виден только в этом же пакете. (В подпакетах не виден, т.к. их не бывает)
    - public - виден всем (помним про имя этого файла тогда)
    - private - не бывает, уходим в котлин.
- class, вложенный в другой
    - public - виден всем
    - private - виден внутри объемлющего класса
    - protected - виден наследникам
- методы - все как и ожидается
- в отличие от плюсов
    ```
    class A{
        protected void foo() {...}
    }
    class B extends A {
        void bar() {
            C = new C();
            c.foo(); // Нельзя дергать протектед штуки из другой иерархии!!!
        }
    class C extends A {}
    ```
- final у класса - от него нельзя наследоваться
- final у метода - его нельзя переопределить в наследнике
- final у static метода - ... это как?

#### Вложенные static и не очень классы
- static - обычные классы, ничего не знают про внешний класс, его имя - просто пространство имен
   ```
    class A { static class AA {} }
    A.AA aa = new A.AA();
    ```
- не static - держат ссылку на внешний класс, имеет доступ ко всем, даже приватным членам внещнего класса
    ```
    class A{
        class AA {
            public getI() { return i; }
        }
        private int i = 64;
    }
    A.AA aa = new A().new AA();
    int outerI = aa.getI();
    ```

#### Ф-ции с переменным числом аргументов
    TODO
    
#### Дженерики

- дружат с массивами как кошка с собакой. Единственный вариант использования вместе (`?`  - wildcard!):
  ```
  List<?> xs = ...;
  ```
TODO


## Общие требования

- SDK 1.8 (Java8 и меньше, соответственно)
- Максимально избегайте хардкода, разделяйте код и данные. 
Например, информация о формате конфигурационного файла должна хваниться в статических полях класса-парсера
(какие символы-разделители используется и т.п.).
- Функция, которую задает алгоритм, должна быть биективной 
(т.е. последовательно применения архиватора и деархиватора должно давать исходный файл).
- Алгоритм должен быть 
[поточным](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC),
т.е. при любом объеме входных данных использовать константное количество оперативной памяти.
(иначе как кино в 40 гигов архивировать).
Таким образом, приложение в цикле должно читать блоки фиксированного размера из файла и 
их последовательно обрабатывать (и сразу записывать в выходной файл), 
пока входной файл не кончится.


## Lab 1

1. Реализовать алгоритм кодирования по вариантам.
2. Реализовать простейшее приложение-архиватор.

#### Пользовательский интерфейс приложения

- Приложение принимает один аргумент командной строки - путь к конфигурационному файлу.
- В конфиге содержится вся информация для работы приложения. Грамматика конфига произвольная.
    - Мод работы (архивировать/деархивировать).
    - Размер буфера.
    - Входной и выходной файлы.
    - мб еще что-нибудь...
- Пользователю в `stdout` должны выводиться осмысленные ошибки, 
не надо пугать пользователя! (т.е. не падать просто на исключениях)
- Подробные данные об ошибках писать в лог. Можно использовать `java.util.logging.Logger'.


## Lab 2

- см Lab3
- отличия от третьей
    - При знакомстве сохраняют ссылки друг на друга, не более.
    - С забирает данные не через какой-то ```DataAccessor```, а напрямую через ```get()``` (с.м. [исходники](https://github.com/kystyn/java/tree/lab2/pipeline) интерфейса второй лабы).


## Lab 3

### UPD

- Ниже описывается контракт для интерфейса `Executor`. 
Гарантируется что при дословном его соблюдении любые две реализации смогут ужиться и работать вместе.
- Никто не запрещает выполнять его лишь частично (например, забить на кодировки).
Но тогда нет гарантии абсолютной совместимости.
- Постулируется лишь интерфейс `Executor`, все остальное можно менять как угодно.
Например, сделать ```interface MyReader extends Reader, Fallible {}```. 


### Знакомство

Manager читает конфиг и выстраивает экзекуторов на конвейер. 
Делает он это в порядке, описанном в конфиге. 
Конвейер получается знакомством соседних экзекуторов.

Считаем что у нас на руках два экзекутора, P и С со статусами OK. Будем их знакомить.

1. ```P.addConsumer(C);```
    - тут P просто сохраняет ссылку на C.
2. ```C.addProducer(P);```
    1. C вызывает ```P.outputDataTypes()```
    2. ```P.outputDataTypes()``` возвращает множество строк - имена типов, 
    в виде которых P может отдавать данные.
    3. С из множества имен типов выбирает один - тот, 
    в каком C хочет получать данные (напр, ```byte[]```).
        - Если же желаемого типа не оказалось, C ставит
        ```status = Status.EXECUTOR_ERROR``` и прекращает общение.
    4. С вызывает ```P.getAccessor(byte[].class.getCanonicalName)``` 
    (подставляем имя того типа, который выбрали).
    5. ```P.getAccessor``` возвращает экземпляр класса, 
    который у продьюсера вложенный и унаследован от ```Producer.DataAccessor```.
    C сохраняет у себя этот экземпляр.
    
На этом знакомство закончилось!

##### DataAccessor

Посмотрим что это такое. Вот пример куска кода продьюсера:
```

private Object output;

private final class DataAccessor implements Producer.DataAccessor {

    @NotNull
    @Override
    public Object get() {
        return output;  // некоторое поле в P
    }

    @Override
    public long size() {
        Objects.requireNonNull(output);
        
        // тут мы знаем, что output это массив, 
        // если строка, вернули бы ((String) output).length()
        return ((byte[]) output).length;  
    }
}

@NotNull
@Override
public Producer.DataAccessor getAccessor(@NotNull final String typeName) {
    // сохраняем себе имя типа, в который будем конвертировать перед отдачей.
    this.outputTypeName = typeName; 
    return new DataAccessor();
}
```

Таким образом, ```DataAccessor``` позволяет C ходить в P и забирать данные.

Также, ```DataAccessor``` может в ```get()``` содержать логику конвертации в выбранный С тип данных,
зависит от реализации.


### Рабочий процесс конвейера

Итак, мы познакомили всех экзекуторов, тем самым сделали конвейер.

##### Запуск!

1. Manager (M) вызывает у первого на конвейере, ридера (R), метод ```R.run()```.
2. В ```run()``` ридер в цикле читает файл по блокам и отправляет на конвейер, работает как продьюсер.

##### Взаимодействие P и C

Допустим, продьюсер обработал данные 
(если продьюсер здесь это ридер, то просто прочитал данные из файла),
сконвертировал в нужный C тип и сложил в переменную output. 
(если произошла ошибка в конвертации или обработке, ставим ```status = Status.EXECUTOR_ERROR``` и делаем ```return```,
не трогая C).

Т.е. мы находимся в методе ```run()``` у P.

Дальше:
1. P вызывает у C ```C.loadDataFrom(this);```
    1. Там С забирает ссылку на данные у продьюсера через сохраненный аксессор:
    ```input = dataAccessor.get()```
    2. Если размер у данных (```dataAccessor.size()```) не равен ожидаемому, ```return 0```
    3. Иначе ```return dataAccessor.size();```
2. P смотрит что вернул ```C.loadDataFrom(this);```
    1. Если вернулся ноль, ставим ```status = Status.EXECUTOR_ERROR;``` и делаем ```return```
    2. Если не ноль, вызываем ```C.run()```
3. После того как ```C.run()``` отработал, ставим ```this.status = C.status()```
    - таким образом статус ошибки, если появится, дойдет до R и тот завершит цикл.
    

### Типы
- поддерживаем
    - byte[]
    - char[]
    - String
- Входной файл должен быть в кодировке UTF-16BE
(можно в idea выбрать справа снизу и переконвертировать)
- Тогда конвертация в коде ваглядит так:
    - ```new String(chars).getBytes("UTF-16BE")``` (char\[\] -> byte\[\])c
    - ```new String(bytes, "UTF-16BE").toCharArray()``` (byte\[\] -> char\[\])
    - к тому же можно полагаться что размер ```byte[]``` в этой кодировке
    будет вдвое длиннее соттветствующего ```char[]```



## Lab 4 

Теперь сделаем архиватор многопоточным. 

Достаточно чтобы работала такая схема:

![scheme](https://i.postimg.cc/jSdh4GXG/java-old-lab4.png)

#### Работа с потоками

Порождение потока - не дешевая операция (но и не слишком дорогая, но все равно...), 
поэтому не будем создавать по 
потоку на каждую порцию данных.

- `Manager` получает данные о количестве потоков из своего конфига, 
знакомит работников с `R` и `W`, выставляя их на конвейер. 
Затем создает для каждого по потоку и запускает их:
    ```
    ...
    for (Executor e : executors) {
        Thread thread = new Thread(e);
        thread.start(); 
    }
    ...
    ```
    [Ничего страшного](https://stackoverflow.com/questions/9651842/will-main-thread-exit-before-child-threads-complete-execution), что главный поток живет меньше дочерних.
- В `run()` каждого `E` находится цикл, в котором он запрашивает данные у `R`,
обрабатывает и отдает в `W`.
- Цикл работает, пока `R` не сообщит, что данных больше не будет.
- Выходной файл должен собраться правильно, поэтому нужно, 
чтобы `R` внимательно раздавал данные 
(а для этого ему нужно знать, какой именно `E` к нему сейчас обращается),
и чтобы `W` собирал данные в правильном порядке.
- Код `R` и `W` используется из многих потоков, поэтому целесообразно пометить их методы как `synchronized`.

Обратная совместимость с предыдущими лабораторными не требуется, но...

#### Lab 3 -> Lab 4

Несложно удовлетворить требованиям выше на интерфейсе для третьей лабы.
(Но в принципе можно воротить что-то принципиально новое).

- В общении `R` и `E` инициатором является `E`, поэтому логика `R` отрабатывает в `DataAccessor.get()`, и, конечно, `R` никакой `loadDataFrom` не дергает. Вниз по течению конвейера все по-старому.
- `R` может узнавать, какой `E` к нему обращается по `DataAccessor`, который ему был выдан.
- Для каждого `E` можно выделить в `R` по ячейке памяти, к которой у него будет доступ через `DataAccessor`.
В этих ячейках хранятся ссылки на данные, поэтому операции с ними атомарны (синхронизация потоков на них не нужна).
- Есть несколько вариантов, как `R` отдавать данные экзекуторам в нужном порядке, 
вне зависимости от того, в каком экзекуторы их запрашивают:
    1. В ячейке держать `null`, пока данных нет, не `null` - иначе.
     (И занулять после удачной попытки `E` обратиться к этой ячейке).
     Но не забываем, что нам нужно уметь через `DataAccessor` уметь сообщать о конце данных,
     для этого нужно будет придумать отдельную штуку.
     `E` когда видит ноль на итерации своего цикла, переходит просто на следующую 
     (можно его тред в сон отправить на долю секунды (`Thread.sleep(2000);`), 
     или что лучше - воспользоваться `wait()` + `notifyAll()`).
    2. Красивый, но существенно более сложный вариант. 
    `R` держит mutex на каждую ячейку (либо через `ожидание условия` (`volatile` флажок, `wait()`...)).
    Когда он из конкретной ячейки готов отдать данные, он отпускает ee блок, 
    а потом в `DataAccessor.get()` сразу берет его опять.
    Тогда можно о конце данных оповещать, отдавая `null` из ячейки.
    
    
#### Thread vs exception!

1. Из `run()`, который запустил `thread.start()` не должно вылетать исключений...
2. Если все-таки планируется что они будут вылетать, можно повесить 
[exception handler](https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html),
и в нем обрабатывать на границе потока. Это сделать обязательно, так как дефолтное поведение - убийство процесса.


