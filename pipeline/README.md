# spbstu-amd-java

В курсе 4 лабораторные работы. Они вместе складываются в один проект - многопоточный архиватор.

[jar для второй](https://drive.google.com/open?id=1V1403Yh38zu5KnZhIjAyO3Tafi8ATXpO). 
Код второй в ветке [lab2](https://github.com/kystyn/java/tree/lab2/pipeline).

[jar для третьей](https://drive.google.com/open?id=1sYT5ZSvtTemLk1aUKl89PxvsbyJ8ovta)


## Разное

Вопросы и пожелания, пожалуйста, пишите в [issues](https://github.com/kystyn/java/issues).

По интерфейсам см также комментарии в исходниках.


## Общие требования

- SDK 1.8 (Java8 и меньше, соответственно)
- Максимально избегайте хардкода, разделяйте код и данные. 
Например, информация о формате конфигурационного файла должна хваниться в статических полях класса-парсера
(какие символы-разделители используется и т.п.).
- Функция, которую задает алгоритм, должна быть биективной 
(т.е. последовательно применения архиватора и деархиватора должно давать исходный файл).
- Алгоритм должен быть 
[поточным](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC),
т.е. при любом объеме входных данных использовать константное количество оперативной памяти.
(иначе как кино в 40 гигов архивировать).
Таким образом, приложение в цикле должно читать блоки фиксированного размера из файла и 
их последовательно обрабатывать (и сразу записывать в выходной файл), 
пока входной файл не кончится.


## Lab 1

1. Реализовать алгоритм кодирования по вариантам.
2. Реализовать простейшее приложение-архиватор.

#### Пользовательский интерфейс приложения

- Приложение принимает один аргумент командной строки - путь к конфигурационному файлу.
- В конфиге содержится вся информация для работы приложения. Грамматика конфига произвольная.
    - Мод работы (архивировать/деархивировать).
    - Размер буфера.
    - Входной и выходной файлы.
    - мб еще что-нибудь...
- Пользователю в `stdout` должны выводиться осмысленные ошибки, 
не надо пугать пользователя! (т.е. не падать просто на исключениях)
- Подробные данные об ошибках писать в лог. Можно использовать `java.util.logging.Logger'.


## Lab 2

- см Lab3
- отличия от третьей
    - При знакомстве сохраняют ссылки друг на друга, не более.
    - С забирает данные не через какой-то ```DataAccessor```, а напрямую через ```get()``` (с.м. [исходники](https://github.com/kystyn/java/tree/lab2/pipeline) интерфейса второй лабы).


## Lab 3

### UPD

- Ниже описывается контракт для интерфейса `Executor`. 
Гарантируется что при дословном его соблюдении любые две реализации смогут ужиться и работать вместе.
- Никто не запрещает выполнять его лишь частично (например, забить на кодировки).
Но тогда нет гарантии абсолютной совместимости.
- Постулируется лишь интерфейс `Executor`, все остальное можно менять как угодно.
Например, сделать ```interface MyReader extends Reader, Fallible {}```. 


### Знакомство

Manager читает конфиг и выстраивает экзекуторов на конвейер. 
Делает он это в порядке, описанном в конфиге. 
Конвейер получается знакомством соседних экзекуторов.

Считаем что у нас на руках два экзекутора, P и С со статусами OK. Будем их знакомить.

1. ```P.addConsumer(C);```
    - тут P просто сохраняет ссылку на C.
2. ```C.addProducer(P);```
    1. C вызывает ```P.outputDataTypes()```
    2. ```P.outputDataTypes()``` возвращает множество строк - имена типов, 
    в виде которых P может отдавать данные.
    3. С из множества имен типов выбирает один - тот, 
    в каком C хочет получать данные (напр, ```byte[]```).
        - Если же желаемого типа не оказалось, C ставит
        ```status = Status.EXECUTOR_ERROR``` и прекращает общение.
    4. С вызывает ```P.getAccessor(byte[].class.getCanonicalName)``` 
    (подставляем имя того типа, который выбрали).
    5. ```P.getAccessor``` возвращает экземпляр класса, 
    который у продьюсера вложенный и унаследован от ```Producer.DataAccessor```.
    C сохраняет у себя этот экземпляр.
    
На этом знакомство закончилось!

##### DataAccessor

Посмотрим что это такое. Вот пример куска кода продьюсера:
```

private Object output;

private final class DataAccessor implements Producer.DataAccessor {

    @NotNull
    @Override
    public Object get() {
        return output;  // некоторое поле в P
    }

    @Override
    public long size() {
        Objects.requireNonNull(output);
        
        // тут мы знаем, что output это массив, 
        // если строка, вернули бы ((String) output).length()
        return ((byte[]) output).length;  
    }
}

@NotNull
@Override
public Producer.DataAccessor getAccessor(@NotNull final String typeName) {
    // сохраняем себе имя типа, в который будем конвертировать перед отдачей.
    this.outputTypeName = typeName; 
    return new DataAccessor();
}
```

Таким образом, ```DataAccessor``` позволяет C ходить в P и забирать данные.

Также, ```DataAccessor``` может в ```get()``` содержать логику конвертации в выбранный С тип данных,
зависит от реализации.


### Рабочий процесс конвейера

Итак, мы познакомили всех экзекуторов, тем самым сделали конвейер.

##### Запуск!

1. Manager (M) вызывает у первого на конвейере, ридера (R), метод ```R.run()```.
2. В ```run()``` ридер в цикле читает файл по блокам и отправляет на конвейер, работает как продьюсер.

##### Взаимодействие P и C

Допустим, продьюсер обработал данные 
(если продьюсер здесь это ридер, то просто прочитал данные из файла),
сконвертировал в нужный C тип и сложил в переменную output. 
(если произошла ошибка в конвертации или обработке, ставим ```status = Status.EXECUTOR_ERROR``` и делаем ```return```,
не трогая C).

Т.е. мы находимся в методе ```run()``` у P.

Дальше:
1. P вызывает у C ```C.loadDataFrom(this);```
    1. Там С забирает ссылку на данные у продьюсера через сохраненный аксессор:
    ```input = dataAccessor.get()```
    2. Если размер у данных (```dataAccessor.size()```) не равен ожидаемому, ```return 0```
    3. Иначе ```return dataAccessor.size();```
2. P смотрит что вернул ```C.loadDataFrom(this);```
    1. Если вернулся ноль, ставим ```status = Status.EXECUTOR_ERROR;``` и делаем ```return```
    2. Если не ноль, вызываем ```C.run()```
3. После того как ```C.run()``` отработал, ставим ```this.status = C.status()```
    - таким образом статус ошибки, если появится, дойдет до R и тот завершит цикл.
    

### Типы
- поддерживаем
    - byte[]
    - char[]
    - String
- Входной файл должен быть в кодировке UTF-16BE
(можно в idea выбрать справа снизу и переконвертировать)
- Тогда конвертация в коде ваглядит так:
    - ```new String(chars).getBytes("UTF-16BE")``` (char\[\] -> byte\[\])c
    - ```new String(bytes, "UTF-16BE").toCharArray()``` (byte\[\] -> char\[\])
    - к тому же можно полагаться что размер ```byte[]``` в этой кодировке
    будет вдвое длиннее соттветствующего ```char[]```



## Lab 4 

Теперь сделаем архиватор многопоточным. 

Достаточно чтобы работала такая схема:

![scheme](https://i.postimg.cc/jSdh4GXG/java-old-lab4.png)

#### Работа с потоками

Порождение потока - не дешевая операция (но и не слишком дорогая, но все равно...), 
поэтому не будем создавать по 
потоку на каждую порцию данных.

- `Manager` получает данные о количестве потоков из своего конфига, 
знакомит работников с `R` и `W`, выставляя их на конвейер. 
Затем создает для каждого по потоку, запускает их и ждет завершения:
    ```
    ...
    for (Executor e : executors) {
        Thread thread = new Thread(e);
        thread.start();
        threads.add(thread);
    }
    for (Thread t : threads) {
        t.join();
    }
    ...
    ```
- В `run()` каждого `E` находится цикл, в котором он запрашивает данные у `R`,
обрабатывает и отдает в `W`.
- Цикл работает, пока `R` не сообщит, что данных больше не будет.
- Выходной файл должен собраться правильно, поэтому нужно, 
чтобы `R` внимательно раздавал данные 
(а для этого ему нужно знать, какой именно `E` к нему сейчас обращается),
и чтобы `W` собирал данные в правильном порядке.
- Код `R` и `W` используется из многих потоков, поэтому целесообразно пометить их методы как `synchronized`.

Обратная совместимость с предыдущими лабораторными не требуется, но...

#### Lab 3 -> Lab 4

Несложно удовлетворить требованиям выше на интерфейсе для третьей лабы.
(Но в принципе можно воротить что-то принципиально новое).

- `R` может узнавать, какой `E` к нему обращается по `DataAccessor`, который ему был выдан.
- Для каждого `E` можно выделить в `R` по ячейке памяти, к которой у него будет доступ через `DataAccessor`.
В этих ячейках хранятся ссылки на данные, поэтому операции с ними атомарны (синхронизация потоков на них не нужна).
- Есть несколько вариантов, как `R` отдавать данные экзекуторам в нужном порядке, 
вне зависимости от того, в каком экзекуторы их запрашивают:
    1. В ячейке держать `null`, пока данных нет, не `null` - иначе.
     (И занулять после удачной попытки `E` обратиться к этой ячейке).
     Но не забываем, что нам нужно уметь через `DataAccessor` уметь сообщать о конце данных,
     для этого нужно будет придумать отдельную штуку.
     `E` когда видит ноль на итерации своего цикла, переходит просто на следующую 
     (можно его тред в сон отправить на долю секунды (для этого не нужен объект треда в `Manager`!!!)).
    2. Красивый, но несколько более сложный вариант. `R` держит mutex на каждую ячейку.
    Когда он из конкретной ячейки готов отдать данные, он отпускает ee mutex, 
    а потом в `DataAccessor.get()` сразу берет его опять.
    Тогда можно о конце данных оповещать, отдавая `null` из ячейки.
    
    
#### Thread vs exception!

1. Из `run()`, который запустил `thread.start()` не должно вылетать исключений...
2. Если все-таки планируется что они будут вылетать, можно повесить 
[exception handler](https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.UncaughtExceptionHandler.html),
и в нем обрабатывать на границе потока. Это сделать обязательно, так как дефолтное поведение - убийство процесса.


